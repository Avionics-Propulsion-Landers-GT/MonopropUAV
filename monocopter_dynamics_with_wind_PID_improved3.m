% What components does the code contain?????

% 1. Physical Parameters:
% - Models a 1kg vehicle with defined moments of inertia
% - Accounts for gravity, drag forces, and thrust limitations
% - Maximum thrust capability of 50 Newtons


% 2. Control System:
% - Uses two PID controllers working in parallel
% - Position controller for X, Y, Z coordinates
% - Attitude controller for roll, pitch, and yaw angles


% 3. Flight Profile:
% - Executes a complete flight cycle over 40 seconds
% - Includes ascent, hover, descent, and landing phases

% What is happening in the code????

% 1. The position control:
% - Computes position errors in all three dimensions
% - Generates desired acceleration commands
% - Uses proportional and derivative gains for smooth corrections
% - Position gains: Kp = [1.5, 1.5, 2.0], Kd = [1.0, 1.0, 1.5]

% 2. The attitude control:
% - Converts desired accelerations into target angles
% - Limits angles to ±30 degrees for stability
% - Uses quaternions to avoid gimbal lock issues
% - Attitude gains: Kp = [8.0, 8.0, 0.0], Kd = [2.0, 2.0, 0.0]

% 3. The flight profile
% - 10-second ascent to 100 meters
% - 5-second hover at peak altitude
% - 10-second controlled descent
% - Final hover phase near ground level

% Wow magic
% So what can we see from the code a.k.a. what graphs do we get
% 1. Position
% 2. Velocity
% 3. Acceleration
% 4. Position Error
% 5. Angular Velocity
% 6. Quaternion Components

% And also the 3D trajectory plot


function monocopter_dynamics_with_wind_PID_improved()
    % Simulation parameters
    dt = 0.01;      % Time step (seconds): Specifies the resolution of the simulation. 
                    % A smaller time step provides higher accuracy but increases computational cost.
    t_end = 40;     % Simulation time (seconds): The total duration for which the simulation runs.
    t = 0:dt:t_end; % Time vector: Discretized time values for the simulation, spanning from 0 to t_end with increments of dt.
    num_steps = length(t);  % Number of time steps: Determines the total number of iterations based on the time vector.

    % Physical constants and parameters
    m = 1.0;       % Mass of the monocopter (kg): Total weight of the rocket, affecting dynamics through Newton's second law.
    g = 9.81;      % Gravitational acceleration (m/s^2): Accounts for the downward force due to Earth's gravity.
    k_D = 0.1;     % Drag coefficient: Affects air resistance proportional to velocity, simulating aerodynamic drag forces.
    k_wind = 0.0;  % Wind drag coefficient set to zero to remove wind disturbances: 
                   % Allows for testing the dynamics without the influence of environmental factors like wind.
    T_max = 50;    % Maximum thrust magnitude (N): Specifies the upper limit of the thrust force generated by the rocket's engines.
    T_min = 0;     % Minimum thrust magnitude (N): Specifies the lower limit of the thrust force, ensuring no reverse thrust.

    % Moments of inertia (kg*m^2)
    I_x = 0.05;    % Moment of inertia about the X-axis: Determines resistance to angular acceleration about this axis.
    I_y = 0.05;    % Moment of inertia about the Y-axis: Determines resistance to angular acceleration about this axis.
    I_z = 0.1;     % Moment of inertia about the Z-axis: Determines resistance to angular acceleration about this axis, typically larger for stability.
    I = diag([I_x, I_y, I_z]);  % Inertia tensor: A diagonal matrix combining moments of inertia, used in torque and angular dynamics calculations.

    % PID controller gains for position control
    Kp_pos = [1.5; 1.5; 2.0];    % Proportional gains for X, Y, Z: Define how aggressively the controller corrects position errors in each axis.
    Ki_pos = [0.0; 0.0; 0.0];    % Integral gains for X, Y, Z: Used to address steady-state errors in position control, currently inactive (set to 0).
    Kd_pos = [1.0; 1.0; 1.5];    % Derivative gains for X, Y, Z: Define the damping behavior by responding to changes in position error rates.

    % PID gains for attitude control
    Kp_att = [8.0; 8.0; 0.0];  % Proportional gains for Roll, Pitch, Yaw: Control the rocket's angular orientation. 
                               % Higher values ensure quicker corrections but may cause instability if set too high.
    Kd_att = [2.0; 2.0; 0.0];  % Derivative gains for Roll, Pitch, Yaw: Provides damping to prevent oscillations in attitude control.

    % Desired trajectory with hover phases
    position_desired = zeros(3, num_steps); % Desired position trajectory (X, Y, Z) over time, initialized to zero.
    T_ascent = 10;       % Time to ascend (seconds): Duration during which the rocket moves upward.
    T_hover_top = 5;     % Hover time at the top (seconds): Duration of stable hover at the highest point of the trajectory.
    T_descent = 10;      % Time to descend (seconds): Duration during which the rocket moves downward toward the starting point.
    T_hover_bottom = t_end - (T_ascent + T_hover_top + T_descent); % Hover time at the bottom (seconds): Remaining time to hover near the ground.

    for i = 1:num_steps
        % Loop over each time step in the simulation
        
        if t(i) <= T_ascent
            % Ascent phase: The rocket climbs vertically from the ground to the target altitude.
            z_desired = (100 / T_ascent) * t(i); % Linear ascent trajectory in the Z-direction.
                                                 % z_desired gradually increases from 0 to 100 meters
                                                 % over the ascent duration of T_ascent seconds.
        elseif t(i) <= T_ascent + T_hover_top
            % Hover at the top phase: The rocket maintains a stable altitude at the peak.
            z_desired = 100;  % Desired altitude stays constant at 100 meters during this phase.
        elseif t(i) <= T_ascent + T_hover_top + T_descent
            % Descent phase: The rocket descends back to the ground in a controlled manner.
            z_desired = 100 - (100 / T_descent) * (t(i) - T_ascent - T_hover_top);  
                                                 % Linear descent trajectory in the Z-direction,
                                                 % reducing z_desired from 100 meters to 0.
        else
            % Hover at the bottom phase: The rocket remains stable near the ground level.
            z_desired = 0;  % Desired altitude is 0 meters for the remainder of the simulation.
        end
        
        % Update the desired position vector at the current time step
        position_desired(:, i) = [0; 0; z_desired];  % Desired position is always (0, 0, z_desired),
                                                    % assuming no lateral movement (X and Y remain 0).
    end
    
    % Initial conditions
    r = [0; 0; 0];          % Initial position (m): The rocket starts at the origin (ground level).
    v = [0; 0; 0];          % Initial velocity (m/s): The rocket starts stationary, with no motion.
    q = [1; 0; 0; 0];       % Initial quaternion: Represents a neutral (no rotation) orientation in 3D space.
    omega = [0; 0; 0];      % Initial angular velocity (rad/s): The rocket starts without any rotational motion.
    
    % Initialize PID controller variables
    previous_error = zeros(3, 1);  % Stores the error from the previous time step for derivative control
                                   % in the PID position control loop.
    
    % Pre-allocate arrays to store results
    position_history = zeros(3, num_steps);       % Stores the rocket's position (X, Y, Z) over time.
    velocity_history = zeros(3, num_steps);       % Stores the rocket's velocity (X, Y, Z) over time.
    acceleration_history = zeros(3, num_steps);   % Stores the rocket's acceleration (X, Y, Z) over time.
    quaternion_history = zeros(4, num_steps);     % Stores the rocket's quaternion (orientation) over time.
    angular_velocity_history = zeros(3, num_steps); % Stores the rocket's angular velocity (roll, pitch, yaw) over time.
    error_history = zeros(3, num_steps);          % Stores the position error (X, Y, Z) at each time step.
    
    % Initialize wind velocity array (no wind)
    v_wind = zeros(3, num_steps);  % Wind velocity (X, Y, Z) at each time step is set to zero, as wind effects
                                   % are disabled in this simulation.
    

    % Main simulation loop
    for step = 1:num_steps
        % Current time
        t_current = t(step);  % Fetch the current time step value.

        % Desired position at current time
        r_desired = position_desired(:, step);  % The target (desired) position in (X, Y, Z) at this time.

        % Compute position error
        error = r_desired - r;  % Difference between desired and current position (X, Y, Z).
        error_history(:, step) = error;  % Record the error for plotting or analysis later.

        % Compute derivative of error
        if step == 1
            error_derivative = zeros(3, 1);  % Initialize to zero for the first step.
        else
            error_derivative = (error - previous_error) / dt;  % Rate of change of position error.
        end

        % PID controller output (desired acceleration in X, Y, Z)
        u = Kp_pos .* error + Kd_pos .* error_derivative;  
        % Generates the control signal as desired acceleration based on position error and its derivative.

        % Update previous error
        previous_error = error;  % Store the current error for the next iteration.

        % Compute desired total thrust (assuming mass normalized)
        F_total = m * (u(3) + g);  % Total thrust required to counteract gravity and achieve desired acceleration.
        if F_total > T_max
            F_total = T_max;  % Saturate thrust to maximum allowed value.
        elseif F_total < T_min
            F_total = T_min;  % Saturate thrust to minimum allowed value.
        end

        % Compute desired roll and pitch angles
        theta_des = u(1) / g;  % Desired pitch angle (rad) based on lateral acceleration in X.
        phi_des = -u(2) / g;   % Desired roll angle (rad) based on lateral acceleration in Y.

        % Limit desired angles to ±30 degrees
        max_angle = deg2rad(30);  % Define maximum allowable angle in radians.
        theta_des = max(min(theta_des, max_angle), -max_angle);  % Clamp pitch angle.
        phi_des = max(min(phi_des, max_angle), -max_angle);  % Clamp roll angle.

        % Desired yaw angle (keep at zero)
        psi_des = 0;  % Assume no yaw rotation for simplicity.

        % Compute desired rotation matrix from desired Euler angles
        R_desired = euler_angles_to_rotation_matrix(phi_des, theta_des, psi_des);

        % Convert current quaternion to rotation matrix
        R_current = quat_to_rotation_matrix(q);  % Convert current orientation quaternion to rotation matrix.

        % Compute rotation error (rotation matrix)
        R_error = R_desired * R_current';  % Calculate the rotational difference between desired and current states.

        % Convert rotation error to Euler angles
        euler_error = rotation_matrix_to_euler_angles(R_error);  % Represents the angular misalignment (roll, pitch, yaw).

        % Desired angular velocities (proportional to rotation errors)
        omega_desired = Kp_att .* euler_error;  % Generate angular velocity commands proportional to orientation errors.

        % Compute angular acceleration required
        omega_error = omega_desired - omega;  % Difference between desired and current angular velocities.
        omega_dot = Kd_att .* omega_error;  % Control signal for angular acceleration.

        % Update angular velocity
        omega = omega + omega_dot * dt;  % Update angular velocity using angular acceleration.

        % Compute quaternion kinematics
        q_dot = 0.5 * omega_matrix(omega) * q;  % Quaternion derivative based on angular velocity.

        % Update quaternion and normalize
        q = q + q_dot * dt;  % Update orientation quaternion.
        q = q / norm(q);  % Normalize to ensure unit quaternion (necessary for numerical stability).

        % Compute the rotation matrix from the updated quaternion
        R_b_to_w = quat_to_rotation_matrix(q);  % Rotation matrix from body frame to world frame.

        % Thrust in body frame (assumed to be along z-axis)
        thrust_body = [0; 0; F_total];  % Thrust vector in the body frame.

        % Thrust in world frame
        thrust_world = R_b_to_w * thrust_body;  % Transform thrust to the world frame using the rotation matrix.

        % Wind velocity at current time (no wind)
        v_wind_current = v_wind(:, step);  % Wind velocity at the current time step (zero in this simulation).

        % Relative velocity between the monocopter and the wind
        v_rel = v - v_wind_current;  % Calculate relative airspeed considering wind velocity.

        % Wind force (zero in this case)
        F_wind = -k_wind * norm(v_rel) * v_rel;  % Force exerted by wind (inactive here as k_wind = 0).

        % Net force = thrust + wind force - gravity - drag
        gravity = [0; 0; -m * g];  % Gravitational force vector in the world frame.
        drag = -k_D * v;  % Aerodynamic drag opposing the velocity.
        F_net = thrust_world + F_wind + drag + gravity;  % Sum of all forces acting on the rocket.

        % Acceleration
        a = F_net / m;  % Compute linear acceleration using Newton's second law.
        acceleration_history(:, step) = a;  % Record acceleration history.

        % Update velocity and position
        v = v + a * dt;  % Update velocity using acceleration.
        r = r + v * dt;  % Update position using velocity.

        % Store history
        position_history(:, step) = r;  % Record position history.
        velocity_history(:, step) = v;  % Record velocity history.
        quaternion_history(:, step) = q;  % Record quaternion history.
        angular_velocity_history(:, step) = omega;  % Record angular velocity history.
    end


    % Plot results
    % Inputs:
    % - position_history: Trajectory of the rocket in the inertial frame (X, Y, Z coordinates over time).
    % - velocity_history: Velocities of the rocket in X, Y, Z directions over time.
    % - acceleration_history: Accelerations of the rocket in X, Y, Z directions over time.
    % - quaternion_history: Quaternion representation of the rocket's orientation at each timestep.
    % - angular_velocity_history: Angular velocities (roll, pitch, yaw rates) over time.
    % - error_history: Difference between desired and actual positions over time.
    % - dt: Time step for the simulation (seconds).
    % - t: Time vector for the simulation.
    % - position_desired: Desired position trajectory in the inertial frame (X, Y, Z coordinates).
    plot_results(position_history, velocity_history, acceleration_history, quaternion_history, angular_velocity_history, error_history, dt, t, position_desired);
end  % End of main function

%% Function to compute rotation matrix from Euler angles
% Converts roll (phi), pitch (theta), and yaw (psi) angles into a 3x3 rotation matrix.
% Inputs:
% - phi: Roll angle (rotation about the X-axis in radians).
% - theta: Pitch angle (rotation about the Y-axis in radians).
% - psi: Yaw angle (rotation about the Z-axis in radians).
% Output:
% - R: Rotation matrix (3x3) mapping from the body frame (attached to the rocket) to the world frame.

% The rotation matrix defines how a vector in the body frame transforms to the world frame.
function R = euler_angles_to_rotation_matrix(phi, theta, psi)
    R = [
        cos(theta)*cos(psi), cos(theta)*sin(psi), -sin(theta);
        sin(phi)*sin(theta)*cos(psi)-cos(phi)*sin(psi), sin(phi)*sin(theta)*sin(psi)+cos(phi)*cos(psi), sin(phi)*cos(theta);
        cos(phi)*sin(theta)*cos(psi)+sin(phi)*sin(psi), cos(phi)*sin(theta)*sin(psi)-sin(phi)*cos(psi), cos(phi)*cos(theta)
    ];
end

%% Function to convert rotation matrix to Euler angles
% Extracts roll (phi), pitch (theta), and yaw (psi) angles from a given 3x3 rotation matrix.
% Input:
% - R: Rotation matrix (3x3) describing the orientation of the body frame with respect to the world frame.
% Output:
% - euler: A 3x1 vector containing the extracted Euler angles [phi; theta; psi].
function euler = rotation_matrix_to_euler_angles(R)
    % Numerical stability is ensured to avoid singularities when extracting angles (e.g., gimbal lock).
    % Handles edge cases where the pitch angle is ±90 degrees, leading to undefined roll/yaw values.
    if abs(R(3,1)) >= 1
        theta = -sign(R(3,1)) * pi / 2;
        phi = 0;
        psi = atan2(-R(1,2), -R(1,3));
    else
        theta = -asin(R(3,1));
        phi = atan2(R(3,2)/cos(theta), R(3,3)/cos(theta));
        psi = atan2(R(2,1)/cos(theta), R(1,1)/cos(theta));
    end
    euler = [phi; theta; psi];
end

%% Function to compute the angular velocity matrix Omega for quaternion kinematics
% Computes the Omega matrix required for quaternion dynamics in the simulation.
% Input:
% - omega: A 3x1 vector of angular velocities [omega_x; omega_y; omega_z] in radians/second.
% Output:
% - Omega: A 4x4 skew-symmetric matrix used in quaternion kinematics.
function Omega = omega_matrix(omega)
    % The Omega matrix maps angular velocity to quaternion rate of change.
    omega_x = omega(1);  % Angular velocity around the X-axis.
    omega_y = omega(2);  % Angular velocity around the Y-axis.
    omega_z = omega(3);  % Angular velocity around the Z-axis.

    % Construct the Omega matrix for quaternion updates.
    Omega = [
        0, -omega_x, -omega_y, -omega_z;
        omega_x, 0, omega_z, -omega_y;
        omega_y, -omega_z, 0, omega_x;
        omega_z, omega_y, -omega_x, 0
    ];
end

%% Function to convert a quaternion to a rotation matrix
% Computes the rotation matrix corresponding to a given quaternion.
% Input:
% - q: A 4x1 quaternion [w; x; y; z], where:
%       w: Scalar component of the quaternion.
%       x, y, z: Vector components of the quaternion.
% Output:
% - R: A 3x3 rotation matrix describing the orientation of the body frame relative to the world frame.
function R = quat_to_rotation_matrix(q)
% The quaternion represents the orientation of the rocket. It is computationally efficient
% for dynamic simulations and avoids singularities present in Euler angles.

% Extract components of the quaternion.
w = q(1);  % Scalar component.
x = q(2);  % X-axis component.
y = q(3);  % Y-axis component.
z = q(4);  % Z-axis component.

    % Compute the corresponding rotation matrix based on quaternion components.
    R = [
        1 - 2*y^2 - 2*z^2,   2*x*y - 2*z*w,       2*x*z + 2*y*w;
        2*x*y + 2*z*w,       1 - 2*x^2 - 2*z^2,   2*y*z - 2*x*w;
        2*x*z - 2*y*w,       2*y*z + 2*x*w,       1 - 2*x^2 - 2*y^2
    ];
end

%% Function to plot simulation results
function plot_results(position_history, velocity_history, acceleration_history, quaternion_history, angular_velocity_history, error_history, dt, t, position_desired)
    time = t;

    % 3D Trajectory plot
    figure;
    plot3(position_history(1, :), position_history(2, :), position_history(3, :), 'b-', 'LineWidth', 1.5);
    hold on;
    plot3(position_desired(1, :), position_desired(2, :), position_desired(3, :), 'r--', 'LineWidth', 1.5);
    grid on;
    title('Monocopter 3D Trajectory');
    xlabel('X Position (m)');
    ylabel('Y Position (m)');
    zlabel('Z Position (m)');
    legend('Actual Path', 'Desired Path');
    view(3);  % Set 3D view for better visualization

    % Position, Velocity, Acceleration, Position Error, Angular Velocity
    figure;
    subplot(6, 1, 1);
    plot(time, position_history(1, :), 'r', time, position_history(2, :), 'g', time, position_history(3, :), 'b');
    hold on;
    plot(time, position_desired(1, :), 'r--', time, position_desired(2, :), 'g--', time, position_desired(3, :), 'b--');
    title('Position (m)');
    xlabel('Time (s)');
    ylabel('Position (m)');
    legend('x', 'y', 'z', 'x_{desired}', 'y_{desired}', 'z_{desired}');

    subplot(6, 1, 2);
    plot(time, velocity_history(1, :), 'r', time, velocity_history(2, :), 'g', time, velocity_history(3, :), 'b');
    title('Velocity (m/s)');
    xlabel('Time (s)');
    ylabel('Velocity (m/s)');
    legend('v_x', 'v_y', 'v_z');

    subplot(6, 1, 3);
    plot(time, acceleration_history(1, :), 'r', time, acceleration_history(2, :), 'g', time, acceleration_history(3, :), 'b');
    title('Acceleration (m/s^2)');
    xlabel('Time (s)');
    ylabel('Acceleration (m/s^2)');
    legend('a_x', 'a_y', 'a_z');

    subplot(6, 1, 4);
    plot(time, error_history(1, :), 'r', time, error_history(2, :), 'g', time, error_history(3, :), 'b');
    title('Position Error (m)');
    xlabel('Time (s)');
    ylabel('Error (m)');
    legend('Error in X', 'Error in Y', 'Error in Z');

    subplot(6, 1, 5);
    plot(time, angular_velocity_history(1, :), 'r', time, angular_velocity_history(2, :), 'g', time, angular_velocity_history(3, :), 'b');
    title('Angular Velocity (rad/s)');
    xlabel('Time (s)');
    ylabel('Angular Velocity (rad/s)');
    legend('\omega_x', '\omega_y', '\omega_z');

    % Quaternion components over time
    subplot(6, 1, 6);
    plot(time, quaternion_history(1, :), 'k', time, quaternion_history(2, :), 'r', time, quaternion_history(3, :), 'g', time, quaternion_history(4, :), 'b');
    title('Quaternion Components');
    xlabel('Time (s)');
    ylabel('Quaternion Value');
    legend('q_0', 'q_1', 'q_2', 'q_3');
end  % End of plot_results function
