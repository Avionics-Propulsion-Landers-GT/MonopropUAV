#include <iostream>
#include <fstream>
#include <cmath>
#include <vector>
#include "../CustomLinear/Matrix.h"
#include "../CustomLinear/Vector.h"
#include "../CustomLinear/Quaternion.h"
#include "../Loop/loop.h"
#include "../Loop/init.h"
#include "../LQR/lqr.h"
#include "../LQR/calculateA.h"
#include "../LQR/calculateB.h"

using namespace std;

//------------------------- Basic Vector Arithmetic Helpers ---------------------------

// I will get rid of these later, generated by Chatgpt
// made by Justin E.

Vector vectorAdd(const Vector &a, const Vector &b) {
    return a.add(b);
}

Vector vectorSubtract(const Vector &a, const Vector &b) {
    return a.add(b.multiply(-1.0));
}

Vector vectorScale(const Vector &a, double scalar) {
    return a.multiply(scalar);
}

//------------------------- State Structure ---------------------------------

struct State {
    Vector pos;         // 3x1 position vector
    Vector vel;         // 3x1 velocity vector
    Vector accel;       // 3x1 acceleration vector
    Quaternion att;     // attitude as a quaternion [w, x, y, z]
    Vector ang_vel;     // 3x1 angular velocity vector
    Vector ang_accel;   // 3x1 angular acceleration vector

    State()
      : pos(3, 0.0),
        vel(3, 0.0),
        accel(3, 0.0),
        // Initialize attitude as identity quaternion: (1, 0, 0, 0)
        att(1.0, 0.0, 0.0, 0.0),
        ang_vel(3, 0.0),
        ang_accel(3, 0.0)
    { }
};

//------------------------- Rocket Parameters Structure ---------------------------

struct RocketParams {
    // Mass and inertia.
    double m_static;
    double m_gimbal_top;
    double m_gimbal_bottom;
    double m;
    
    // Offsets as 3x1 vectors.
    Vector gimbal_top_COM_offset;
    Vector gimbal_bottom_COM_offset;
    Vector COM_offset;
    Vector COP;
    Vector COP_offset;
    Vector gimbal_offset;
    Vector gimbal_x_distance;
    Vector gimbal_y_distance;
    
    // Physical constants.
    double g;         // gravitational acceleration
    double Cd_x, Cd_y, Cd_z;
    double A_x, A_y, A_z;
    double air_density;
    
    // Inertia matrix and its inverse.
    Matrix I;
    Matrix Inv_I;
    
    // Gimbal inertias.
    double gimbal_top_I;
    double gimbal_bottom_I;
    
    // Thrust limits and gimbal limits.
    double T_max, T_min;
    double gimbal_speed;
    double gimbal_acceleration;
    
    double dt;      // simulation timestep.

    RocketParams() 
      : m_static(0.0), m_gimbal_top(0.0), m_gimbal_bottom(0.0), m(0.0),
        // Initialize 3x1 vectors (for example, setting all entries to zero)
        gimbal_top_COM_offset(3, 0.0),
        gimbal_bottom_COM_offset(3, 0.0),
        COM_offset(3, 0.0),
        COP(3, 0.0),
        COP_offset(3, 0.0),
        gimbal_offset(3, 0.0),
        gimbal_x_distance(3, 0.0),
        gimbal_y_distance(3, 0.0),
        // Physical constants.
        g(9.81),
        Cd_x(0.1), Cd_y(0.1), Cd_z(0.1),
        A_x(0.7), A_y(0.7), A_z(0.3),
        air_density(1.225),
        // Initialize a 3x3 Matrix with zeros.
        I(3, 3, 0.0),
        Inv_I(3, 3, 0.0),
        // Gimbal inertias.
        gimbal_top_I(1.0),
        gimbal_bottom_I(1.0),
        // Thrust and gimbal limits.
        T_max(100.0), T_min(0.0),
        gimbal_speed(5.0),
        gimbal_acceleration(2.0),
        dt(0.001)
    {    }
};

//------------------------- Quaternion-Based Dynamics Update ---------------------------

/*
   Update the state (position, velocity, attitude, angular velocity) using Euler integration.
   For the rotational update we use:
       q_dot = 0.5 * (att * ω_quat)
   where ω_quat is [0, ω], and then:
       att_new = att + q_dot * dt, then normalized.
*/
State update_dynamics(const RocketParams &P,
                      const Vector &pos,
                      const Vector &vel,
                      const Quaternion &att,
                      const Vector &ang_vel,
                      const Vector &F_net,
                      const Vector &T_net,
                      double delta_t)
{
    State newState;
    // std::cout << "Translational update\n";
    // --- Translational update ---
    Vector accel = F_net.multiply(1.0 / P.m);
    Vector vel_new = vectorAdd(vel, vectorScale(accel, delta_t));
    Vector pos_new = vectorAdd(pos, vectorScale(vel_new, delta_t));
    // std::cout << "Rotational update\n";

    // --- Rotational update ---
    // Angular acceleration: ang_accel = Inv_I * T_net.
    Vector ang_accel = P.Inv_I.multiply(T_net);
    Vector ang_vel_new = vectorAdd(ang_vel, vectorScale(ang_accel, delta_t));
    
    // Create an "omega quaternion" from the new angular velocity.
    // Standard formulation: ω_quat = [0, ωx, ωy, ωz]
    // std::cout << "Quaternion update\n";

    Quaternion omega(0, ang_vel_new(0,0), ang_vel_new(1,0), ang_vel_new(2,0));
    // Compute quaternion derivative: q_dot = 0.5 * (att * ω_quat)
    Quaternion q_dot = att * omega * 0.5;
    // Euler integrate: att_new = att + q_dot * dt, then normalize.
    Quaternion att_new = att + q_dot * delta_t;
    att_new = att_new.normalize();
    // std::cout << "Assign new values\n";

    newState.pos = pos_new;
    newState.vel = vel_new;
    newState.accel = accel;
    newState.att = att_new;
    newState.ang_vel = ang_vel_new;
    newState.ang_accel = ang_accel;
    // std::cout << "Return new values\n";

    return newState;
    // std::cout << "Returned\n";
}

//------------------------- Extrinsic Rotation Functions ---------------------------

// These use our custom Matrix and Vector classes. Here we assume that get_extrinsic_x_rotation,
// get_extrinsic_y_rotation, and get_extrinsic_z_rotation are defined below (or reuse the ones from earlier).

Matrix get_extrinsic_x_rotation(double x) {
    Matrix R(3,3,0.0);
    R(0,0) = 1;       R(0,1) = 0;         R(0,2) = 0;
    R(1,0) = 0;       R(1,1) = cos(x);    R(1,2) = -sin(x);
    R(2,0) = 0;       R(2,1) = sin(x);    R(2,2) = cos(x);
    return R;
}

Matrix get_extrinsic_y_rotation(double y) {
    Matrix R(3,3,0.0);
    R(0,0) = cos(y);  R(0,1) = 0;         R(0,2) = sin(y);
    R(1,0) = 0;       R(1,1) = 1;         R(1,2) = 0;
    R(2,0) = -sin(y); R(2,1) = 0;         R(2,2) = cos(y);
    return R;
}

Matrix get_extrinsic_z_rotation(double z) {
    Matrix R(3,3,0.0);
    R(0,0) = cos(z);  R(0,1) = -sin(z);   R(0,2) = 0;
    R(1,0) = sin(z);  R(1,1) = cos(z);    R(1,2) = 0;
    R(2,0) = 0;       R(2,1) = 0;         R(2,2) = 1;
    return R;
}

// Given Euler angles [x, y, z] in a Vector (3x1), return extrinsic rotation matrix.
Matrix get_extrinsic_rotation_matrix(const Vector &euler) {
    double x = euler(0,0), y = euler(1,0), z = euler(2,0);
    // Note: Apply rotations in z-y-x order.
    Matrix R = get_extrinsic_z_rotation(z).multiply(get_extrinsic_y_rotation(y)).multiply(get_extrinsic_x_rotation(x));
    return R;
}

//------------------------- Thrust and Drag Models ---------------------------

/*
   get_thrust_body:
   Computes the thrust force and torque in the body frame.
   For simplicity the gimbal (thrust steering) is held zero.
*/
pair<Vector, Vector> get_thrust_body(const RocketParams &P, double F_thrust_mag, const Vector &thrust_gimbal) {
    // Compute rotation matrix from thrust_gimbal; here thrust_gimbal is a 3x1 vector.
    Matrix R = get_extrinsic_rotation_matrix(thrust_gimbal);
    // Unit vector in z direction.
    Vector ez(3, 0.0);
    ez(2,0) = 1.0;
    
    // thrust_force = F_thrust_mag * (R * ez)
    Vector thrust_force = R.multiply(ez).multiply(F_thrust_mag);
    
    // For torque: r = COM_offset + gimbal_offset + (get_extrinsic_x_rotation(thrust_gimbal(0)) * gimbal_x_distance) +
    // (R * gimbal_y_distance)
    Vector r = P.COM_offset;
    r = vectorAdd(r, P.gimbal_offset);
    // (Assuming the offsets are all zero in our simple model, r remains zero.)
    Vector thrust_torque = r.crossProduct(thrust_force);
    
    return make_pair(thrust_force, thrust_torque);
}

/*
   get_drag_body:
   Computes drag force and drag-induced torque.
   Uses the transformation of velocity into the body frame via the attitude quaternion.
*/
pair<Vector, Vector> get_drag_body(const RocketParams &P, const Quaternion &att, const Vector &vel, const Vector &v_wind) {
    Vector vel_rel = vectorSubtract(vel, v_wind); // relative velocity in world frame
    // Convert vel_rel into body frame: use att.inverse().toRotationMatrix()
    Quaternion att_inv = att.inverse();
    Matrix R_body = att_inv.toRotationMatrix();
    Vector vel_rel_body = R_body.multiply(vel_rel);
    
    // vel_rel_body is a 0 vector right now. 
    double v_rel_norm = vel_rel_body.magnitude();
    // Build a diagonal vector for drag coefficients.
    // is this really a diagonal "vector"??? - Justin
    Vector diagVals(3, 0.0);
    diagVals(0,0) = P.Cd_x * P.A_x;
    diagVals(1,0) = P.Cd_y * P.A_y;
    diagVals(2,0) = P.Cd_z * P.A_z;
    // cout << "get drag body func check 2\n";
    double factor = 0.5 * P.air_density * v_rel_norm;
    Vector drag_force = vel_rel_body; 
    // Elementwise multiply by diagVals.
    for (unsigned int i = 0; i < 3; i++) {
        double temp = drag_force(i,0) * diagVals(i,0);
        drag_force(i,0) = -factor * temp;
    }
    // cout << "get drag body func check 3\n";
    // Drag torque: COP_offset x drag_force.
    Vector drag_torque = P.COP_offset.crossProduct(drag_force);
    return make_pair(drag_force, drag_torque);
}

/*
   Placeholder for calculating COM and COP offsets.
   In this simplified model (with all offsets zero), nothing is done.
*/
void calculate_COM_and_COP_offset(RocketParams &P, const Vector &thrust_gimbal) {
    // In a detailed model, you would update P.COM_offset and P.COP_offset here.
    // We leave them unchanged.
}

//------------------------- Simulation Function ---------------------------

void simulate(RocketParams &P) {
    double t_end = 40.0;         // total simulation time in seconds
    double dt = P.dt;
    int num_steps = static_cast<int>(round(t_end / dt)) + 1;
    
    // Build time vector
    vector<double> time(num_steps);
    for (int i = 0; i < num_steps; i++) {
        time[i] = i * dt;
    }
    
    // Initial conditions
    Vector pos(3, 0.0);            // 3x1 zero vector for position
    std::vector<double> gpsInit = {pos(0,0), pos(1,0), pos(2,0)};
    // Initialize position as a 3x1 vector, expected by init function defining SystemComponents
    Vector vel(3, 0.0);            // 3x1 zero velocity
    std::vector<double> vel_std = {vel(0,0), vel(1,0), vel(2,0)};
    Quaternion att(1, 0, 0, 0);    // Initial attitude: identity quaternion
    // Matrix attEulerMatrix = att.toEulerMatrix();
    Vector att_euler(3, 0.0);      // Euler angles (roll, pitch, yaw)
    std::vector<double> att_euler_std = {att_euler(0,0), att_euler(1,0), att_euler(2,0)};
    Vector ang_vel(3, 0.0);        // angular velocity zero
    std::vector<double> ang_vel_std = {ang_vel(0,0), ang_vel(1,0), ang_vel(2,0)};

    
    // Initialize control variables
    Vector thrust_gimbal(3, 0.0);
    double F_thrust_mag = 0.0;
    
    // Initialize LQR components
    std::vector<std::vector<double>> initState = {{gpsInit},{vel_std}, {att_euler_std}, {ang_vel_std}};
    SystemComponents system = init(gpsInit, initState, dt); 
    unsigned int iter = 0;
    std::vector<double> prevCommand = {0, 0, 0};
    std::vector<double> prevPrevCommand = {0, 0, 0};
    std::vector<bool> status = {true, true};
    
    // Pre-allocate history
    vector<Vector> pos_history;
    vector<Vector> vel_history;
    vector<Vector> command_history;
    pos_history.reserve(num_steps);
    vel_history.reserve(num_steps);
    command_history.reserve(num_steps);
    
    // Build desired trajectory: pure vertical motion
    vector<Vector> pos_desired;
    pos_desired.reserve(num_steps);
    double T_ascent = 10.0;
    double T_hover_top = 5.0;
    double T_descent = 10.0;
    for (int i = 0; i < num_steps; i++) {
        double t_val = time[i];
        double z_desired = 0.0;
        if (t_val <= T_ascent)
            z_desired = (100.0 / T_ascent) * t_val;
        else if (t_val <= T_ascent + T_hover_top)
            z_desired = 100.0;
        else if (t_val <= T_ascent + T_hover_top + T_descent)
            z_desired = 100.0 - (100.0 / T_descent) * (t_val - T_ascent - T_hover_top);
        else
            z_desired = 0.0;
        Vector des(3, 0.0);
        des(2,0) = z_desired;
        pos_desired.push_back(des);
    }
    
    // Zero wind
    Vector v_wind(3, 0.0);
    
    // Main simulation loop
    for (int step = 0; step < num_steps; step++) {
        // -------------------- LQR CONTROL CALCULATION --------------------
        
        // 1. Convert current state to the format expected by the LQR
        std::vector<double> position = {pos(0,0), pos(1,0), pos(2,0)};
        std::vector<double> velocity = {vel(0,0), vel(1,0), vel(2,0)};
        
        // Convert quaternion to Euler angles for the LQR
        Matrix euler_attitude_mat = att.toEulerMatrix();
        // convert euler matrix to std::vector
        std::vector<double> euler_attitude = {euler_attitude_mat(0,0), 
                                              euler_attitude_mat(1,0), 
                                              euler_attitude_mat(2,0)};
        
        std::vector<double> angular_velocity = {ang_vel(0,0), ang_vel(1,0), ang_vel(2,0)};
        
        // Current state in the format expected by LQR
        std::vector<std::vector<double>> current_state = {position, velocity, euler_attitude, angular_velocity};
        
        // Previous state (use current state if it's the first iteration)
        std::vector<std::vector<double>> previous_state = (step > 0) ? 
                                                       current_state : current_state;
        
        // 2. Calculate desired state from trajectory
        std::vector<double> desired_position = {pos_desired[step](0,0), 
                                               pos_desired[step](1,0), 
                                               pos_desired[step](2,0)};
        
        // Calculate velocity setpoint based on trajectory (simple difference if needed)
        std::vector<double> desired_velocity = {0, 0, 0};
        if (step < num_steps - 1) {
            desired_velocity[0] = (pos_desired[step+1](0,0) - pos_desired[step](0,0)) / dt;
            desired_velocity[1] = (pos_desired[step+1](1,0) - pos_desired[step](1,0)) / dt;
            desired_velocity[2] = (pos_desired[step+1](2,0) - pos_desired[step](2,0)) / dt;
        }
        
        // Full desired state vector
        std::vector<double> desired_state = {
            desired_position[0], desired_position[1], desired_position[2],
            desired_velocity[0], desired_velocity[1], desired_velocity[2],
            0, 0, 0,  // desired attitude (usually zero for hover)
            0, 0, 0   // desired angular velocity (usually zero)
        };
        
        // Delta desired state for LQR
        std::vector<double> delta_desired_state(12, 0.0);
        // Compute actual delta if needed based on trajectory
        
        // 3. Set up the input structure for the LQR loop function
        std::vector<std::vector<double>> sensor_values = {
            {0, ang_vel(0,0), ang_vel(1,0), ang_vel(2,0), 0, 0, 0, 0, 0, 0}, // Mock IMU data
            {0, ang_vel(0,0), ang_vel(1,0), ang_vel(2,0), 0, 0, 0}, // Mock 6-axis IMU
            {0, 0, pos(2,0)}, // Mock GPS
            {0, pos(2,0)}, // Mock LIDAR
            {0, pos(0,0), pos(1,0), 0} // Mock UWB
        };
        
        // Create loop input structure
        LoopInput loopInput = {
            sensor_values,
            current_state,
            previous_state,
            system,
            status,
            dt,
            desired_state,
            delta_desired_state,
            prevCommand,
            prevPrevCommand,
            prevCommand,
            iter
        };
        
        // 4. Call the loop function to get control commands
        LoopOutput loopOutput = loop(loopInput);
        
        // 5. Extract commands from the loop output
        std::vector<double> command = loopOutput.filteredCommand;
        
        // Update previous commands for next iteration
        prevPrevCommand = prevCommand;
        prevCommand = command;
        
        // 6. Convert commands to thrust and gimbal angles
        F_thrust_mag = command[0];  // Thrust magnitude
        thrust_gimbal(0,0) = command[1];  // X-axis gimbal angle
        thrust_gimbal(1,0) = command[2];  // Y-axis gimbal angle
        
        // Clamp thrust to limits
        if (F_thrust_mag < P.T_min) F_thrust_mag = P.T_min;
        if (F_thrust_mag > P.T_max) F_thrust_mag = P.T_max;
        
        // -------------------- DYNAMICS SIMULATION --------------------
        
        // Gravity force (world frame)
        Vector F_gravity(3, 0.0);
        F_gravity(2,0) = -P.m * P.g;
        
        // Update COM and COP offsets
        calculate_COM_and_COP_offset(P, thrust_gimbal);
        
        // Compute thrust force and torque (body frame)
        pair<Vector, Vector> thrust = get_thrust_body(P, F_thrust_mag, thrust_gimbal);
        Vector F_thrust_body = thrust.first;
        Vector T_thrust_body = thrust.second;
        
        // Compute drag force and torque
        pair<Vector, Vector> drag = get_drag_body(P, att, vel, v_wind);
        Vector F_drag_body = drag.first;
        Vector T_drag_body = drag.second;
        
        // Transform body-frame forces to world frame
        Matrix R_att = att.toRotationMatrix();
        Vector F_thrust_world = R_att.multiply(F_thrust_body);
        Vector F_drag_world = R_att.multiply(F_drag_body);
        Vector F_net = vectorAdd(F_gravity, vectorAdd(F_thrust_world, F_drag_world));
        
        // Total torque
        Vector T_net = R_att.multiply(T_thrust_body.add(T_drag_body));
        
        // Update dynamics
        State st = update_dynamics(P, pos, vel, att, ang_vel, F_net, T_net, dt);
        pos = st.pos;
        vel = st.vel;
        att = st.att;
        ang_vel = st.ang_vel;
        
        // Record history
        pos_history.push_back(pos);
        vel_history.push_back(vel);
        // command_history.push_back(Vector(3, {F_thrust_mag, thrust_gimbal(0,0), thrust_gimbal(1,0)}));
        
        // Increment iteration counter
        iter++;
    }
    
    // Write simulation history to CSV
    ofstream file("simulation_results.csv");
    if (!file) {
        cerr << "Error opening simulation_results.csv for writing." << endl;
        return;
    }
    
    // Write header
    file << "time,x,y,z,vx,vy,vz,thrust,gimbal_x,gimbal_y\n";
    
    // Write data rows
    for (int i = 0; i < num_steps; i++) {
        file << time[i] << ","
             << pos_history[i](0,0) << "," << pos_history[i](1,0) << "," << pos_history[i](2,0) << ","
             << vel_history[i](0,0) << "," << vel_history[i](1,0) << "," << vel_history[i](2,0) << ","
             << command_history[i](0,0) << "," << command_history[i](1,0) << "," << command_history[i](2,0) << "\n";
    }
    
    file.close();
    cout << "Simulation complete. Results written to simulation_results.csv" << endl;
}

//------------------------- Main Entry Point ---------------------------

int main() {
    // Define and initialize rocket parameters.
    RocketParams P;
    P.m_static = 1.0;
    P.m_gimbal_top = 1.0;
    P.m_gimbal_bottom = 1.0;
    P.m = P.m_static + P.m_gimbal_top + P.m_gimbal_bottom;
    
    // Set all offset vectors to zero (3x1).
    P.gimbal_top_COM_offset = Vector(3, 0.0);
    P.gimbal_bottom_COM_offset = Vector(3, 0.0);
    P.COM_offset = Vector(3, 0.0);
    P.COP = Vector(3, 0.0);          // Can be set as needed.
    P.COP_offset = Vector(3, 0.0);
    P.gimbal_offset = Vector(3, 0.0);
    P.gimbal_x_distance = Vector(3, 0.0);
    P.gimbal_y_distance = Vector(3, 0.0);
    
    P.g = 9.81;
    P.Cd_x = 0.1;  P.Cd_y = 0.1;  P.Cd_z = 0.1;
    P.A_x = 0.7;   P.A_y = 0.7;   P.A_z = 0.3;
    P.air_density = 1.225;
    
    // Inertia: define a 3x3 matrix.
    P.I = Matrix(3, 3, 0.0);
    P.I(0,0) = 1;  P.I(0,1) = 0;  P.I(0,2) = 0;
    P.I(1,0) = 0;  P.I(1,1) = 1;  P.I(1,2) = 0;
    P.I(2,0) = 0;  P.I(2,1) = 0;  P.I(2,2) = 1;
    P.Inv_I = P.I.inverse();
    
    P.gimbal_top_I = 1.0;
    P.gimbal_bottom_I = 1.0;
    
    P.T_max = 100.0;
    P.T_min = 0.0;
    P.gimbal_speed = 5.0;
    P.gimbal_acceleration = 2.0;
    
    P.dt = 0.001;
    
    simulate(P);
    return 0;
}
