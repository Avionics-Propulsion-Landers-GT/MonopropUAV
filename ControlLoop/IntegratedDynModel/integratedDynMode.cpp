#include <iostream>
#include <fstream>
#include <cmath>
#include <vector>
#include "../CustomLinear/Matrix.h"
#include "../CustomLinear/Vector.h"
#include "../CustomLinear/Quaternion.h"

using namespace std;

//------------------------- Basic Vector Arithmetic Helpers ---------------------------

// I will get rid of these later, generated by Chatgpt
// made by Justin E.

Vector vectorAdd(const Vector &a, const Vector &b) {
    return a.add(b);
}

Vector vectorSubtract(const Vector &a, const Vector &b) {
    return a.add(b.multiply(-1.0));
}

Vector vectorScale(const Vector &a, double scalar) {
    return a.multiply(scalar);
}

//------------------------- State Structure ---------------------------------

struct State {
    Vector pos;         // 3x1 position vector
    Vector vel;         // 3x1 velocity vector
    Vector accel;       // 3x1 acceleration vector
    Quaternion att;     // attitude as a quaternion [w, x, y, z]
    Vector ang_vel;     // 3x1 angular velocity vector
    Vector ang_accel;   // 3x1 angular acceleration vector

    State()
      : pos(3, 0.0),
        vel(3, 0.0),
        accel(3, 0.0),
        // Initialize attitude as identity quaternion: (1, 0, 0, 0)
        att(1.0, 0.0, 0.0, 0.0),
        ang_vel(3, 0.0),
        ang_accel(3, 0.0)
    { }
};

//------------------------- Rocket Parameters Structure ---------------------------

struct RocketParams {
    // Mass and inertia.
    double m_static;
    double m_gimbal_top;
    double m_gimbal_bottom;
    double m;
    
    // Offsets as 3x1 vectors.
    Vector gimbal_top_COM_offset;
    Vector gimbal_bottom_COM_offset;
    Vector COM_offset;
    Vector COP;
    Vector COP_offset;
    Vector gimbal_offset;
    Vector gimbal_x_distance;
    Vector gimbal_y_distance;
    
    // Physical constants.
    double g;         // gravitational acceleration
    double Cd_x, Cd_y, Cd_z;
    double A_x, A_y, A_z;
    double air_density;
    
    // Inertia matrix and its inverse.
    Matrix I;
    Matrix Inv_I;
    
    // Gimbal inertias.
    double gimbal_top_I;
    double gimbal_bottom_I;
    
    // Thrust limits and gimbal limits.
    double T_max, T_min;
    double gimbal_speed;
    double gimbal_acceleration;
    
    double dt;      // simulation timestep.

    RocketParams() 
      : m_static(0.0), m_gimbal_top(0.0), m_gimbal_bottom(0.0), m(0.0),
        // Initialize 3x1 vectors (for example, setting all entries to zero)
        gimbal_top_COM_offset(3, 0.0),
        gimbal_bottom_COM_offset(3, 0.0),
        COM_offset(3, 0.0),
        COP(3, 0.0),
        COP_offset(3, 0.0),
        gimbal_offset(3, 0.0),
        gimbal_x_distance(3, 0.0),
        gimbal_y_distance(3, 0.0),
        // Physical constants.
        g(9.81),
        Cd_x(0.1), Cd_y(0.1), Cd_z(0.1),
        A_x(0.7), A_y(0.7), A_z(0.3),
        air_density(1.225),
        // Initialize a 3x3 Matrix with zeros.
        I(3, 3, 0.0),
        Inv_I(3, 3, 0.0),
        // Gimbal inertias.
        gimbal_top_I(1.0),
        gimbal_bottom_I(1.0),
        // Thrust and gimbal limits.
        T_max(100.0), T_min(0.0),
        gimbal_speed(5.0),
        gimbal_acceleration(2.0),
        dt(0.001)
    {    }
};

//------------------------- Quaternion-Based Dynamics Update ---------------------------

/*
   Update the state (position, velocity, attitude, angular velocity) using Euler integration.
   For the rotational update we use:
       q_dot = 0.5 * (att * ω_quat)
   where ω_quat is [0, ω], and then:
       att_new = att + q_dot * dt, then normalized.
*/
State update_dynamics(const RocketParams &P,
                      const Vector &pos,
                      const Vector &vel,
                      const Quaternion &att,
                      const Vector &ang_vel,
                      const Vector &F_net,
                      const Vector &T_net,
                      double delta_t)
{
    State newState;
    // std::cout << "Translational update\n";
    // --- Translational update ---
    Vector accel = F_net.multiply(1.0 / P.m);
    Vector vel_new = vectorAdd(vel, vectorScale(accel, delta_t));
    Vector pos_new = vectorAdd(pos, vectorScale(vel_new, delta_t));
    // std::cout << "Rotational update\n";

    // --- Rotational update ---
    // Angular acceleration: ang_accel = Inv_I * T_net.
    Vector ang_accel = P.Inv_I.multiply(T_net);
    Vector ang_vel_new = vectorAdd(ang_vel, vectorScale(ang_accel, delta_t));
    
    // Create an "omega quaternion" from the new angular velocity.
    // Standard formulation: ω_quat = [0, ωx, ωy, ωz]
    // std::cout << "Quaternion update\n";

    Quaternion omega(0, ang_vel_new(0,0), ang_vel_new(1,0), ang_vel_new(2,0));
    // Compute quaternion derivative: q_dot = 0.5 * (att * ω_quat)
    Quaternion q_dot = att * omega * 0.5;
    // Euler integrate: att_new = att + q_dot * dt, then normalize.
    Quaternion att_new = att + q_dot * delta_t;
    att_new = att_new.normalize();
    // std::cout << "Assign new values\n";

    newState.pos = pos_new;
    newState.vel = vel_new;
    newState.accel = accel;
    newState.att = att_new;
    newState.ang_vel = ang_vel_new;
    newState.ang_accel = ang_accel;
    // std::cout << "Return new values\n";

    return newState;
    // std::cout << "Returned\n";
}

//------------------------- Extrinsic Rotation Functions ---------------------------

// These use our custom Matrix and Vector classes. Here we assume that get_extrinsic_x_rotation,
// get_extrinsic_y_rotation, and get_extrinsic_z_rotation are defined below (or reuse the ones from earlier).

Matrix get_extrinsic_x_rotation(double x) {
    Matrix R(3,3,0.0);
    R(0,0) = 1;       R(0,1) = 0;         R(0,2) = 0;
    R(1,0) = 0;       R(1,1) = cos(x);    R(1,2) = -sin(x);
    R(2,0) = 0;       R(2,1) = sin(x);    R(2,2) = cos(x);
    return R;
}

Matrix get_extrinsic_y_rotation(double y) {
    Matrix R(3,3,0.0);
    R(0,0) = cos(y);  R(0,1) = 0;         R(0,2) = sin(y);
    R(1,0) = 0;       R(1,1) = 1;         R(1,2) = 0;
    R(2,0) = -sin(y); R(2,1) = 0;         R(2,2) = cos(y);
    return R;
}

Matrix get_extrinsic_z_rotation(double z) {
    Matrix R(3,3,0.0);
    R(0,0) = cos(z);  R(0,1) = -sin(z);   R(0,2) = 0;
    R(1,0) = sin(z);  R(1,1) = cos(z);    R(1,2) = 0;
    R(2,0) = 0;       R(2,1) = 0;         R(2,2) = 1;
    return R;
}

// Given Euler angles [x, y, z] in a Vector (3x1), return extrinsic rotation matrix.
Matrix get_extrinsic_rotation_matrix(const Vector &euler) {
    double x = euler(0,0), y = euler(1,0), z = euler(2,0);
    // Note: Apply rotations in z-y-x order.
    Matrix R = get_extrinsic_z_rotation(z).multiply(get_extrinsic_y_rotation(y)).multiply(get_extrinsic_x_rotation(x));
    return R;
}

//------------------------- Thrust and Drag Models ---------------------------

/*
   get_thrust_body:
   Computes the thrust force and torque in the body frame.
   For simplicity the gimbal (thrust steering) is held zero.
*/
pair<Vector, Vector> get_thrust_body(const RocketParams &P, double F_thrust_mag, const Vector &thrust_gimbal) {
    // Compute rotation matrix from thrust_gimbal; here thrust_gimbal is a 3x1 vector.
    Matrix R = get_extrinsic_rotation_matrix(thrust_gimbal);
    // Unit vector in z direction.
    Vector ez(3, 0.0);
    ez(2,0) = 1.0;
    
    // thrust_force = F_thrust_mag * (R * ez)
    Vector thrust_force = R.multiply(ez).multiply(F_thrust_mag);
    
    // For torque: r = COM_offset + gimbal_offset + (get_extrinsic_x_rotation(thrust_gimbal(0)) * gimbal_x_distance) +
    // (R * gimbal_y_distance)
    Vector r = P.COM_offset;
    r = vectorAdd(r, P.gimbal_offset);
    // (Assuming the offsets are all zero in our simple model, r remains zero.)
    Vector thrust_torque = r.crossProduct(thrust_force);
    
    return make_pair(thrust_force, thrust_torque);
}

/*
   get_drag_body:
   Computes drag force and drag-induced torque.
   Uses the transformation of velocity into the body frame via the attitude quaternion.
*/
pair<Vector, Vector> get_drag_body(const RocketParams &P, const Quaternion &att, const Vector &vel, const Vector &v_wind) {
    Vector vel_rel = vectorSubtract(vel, v_wind); // relative velocity in world frame
    // Convert vel_rel into body frame: use att.inverse().toRotationMatrix()
    Quaternion att_inv = att.inverse();
    Matrix R_body = att_inv.toRotationMatrix();
    Vector vel_rel_body = R_body.multiply(vel_rel);
    
    // vel_rel_body is a 0 vector right now. 
    double v_rel_norm = vel_rel_body.magnitude();
    // Build a diagonal vector for drag coefficients.
    // is this really a diagonal "vector"??? - Justin
    Vector diagVals(3, 0.0);
    diagVals(0,0) = P.Cd_x * P.A_x;
    diagVals(1,0) = P.Cd_y * P.A_y;
    diagVals(2,0) = P.Cd_z * P.A_z;
    // cout << "get drag body func check 2\n";
    double factor = 0.5 * P.air_density * v_rel_norm;
    Vector drag_force = vel_rel_body; 
    // Elementwise multiply by diagVals.
    for (unsigned int i = 0; i < 3; i++) {
        double temp = drag_force(i,0) * diagVals(i,0);
        drag_force(i,0) = -factor * temp;
    }
    // cout << "get drag body func check 3\n";
    // Drag torque: COP_offset x drag_force.
    Vector drag_torque = P.COP_offset.crossProduct(drag_force);
    return make_pair(drag_force, drag_torque);
}

/*
   Placeholder for calculating COM and COP offsets.
   In this simplified model (with all offsets zero), nothing is done.
*/
void calculate_COM_and_COP_offset(RocketParams &P, const Vector &thrust_gimbal) {
    // In a detailed model, you would update P.COM_offset and P.COP_offset here.
    // We leave them unchanged.
}

//------------------------- Simulation Function ---------------------------

void simulate(RocketParams &P) {
    double t_end = 40.0;         // total simulation time in seconds
    double dt = P.dt;
    int num_steps = static_cast<int>(round(t_end / dt)) + 1;
    
    // Build time vector.
    vector<double> time(num_steps);
    for (int i = 0; i < num_steps; i++) {
        time[i] = i * dt;
    }
    
    // Initial conditions.
    Vector pos(3, 0.0);            // 3x1 zero vector for position.
    Vector vel(3, 0.0);            // 3x1 zero velocity.
    // Initial attitude: identity quaternion (1, 0, 0, 0)
    Quaternion att(1, 0, 0, 0);
    Vector ang_vel(3, 0.0);        // angular velocity zero.
    
    // Fixed (zero) gimbal.
    Vector thrust_gimbal(3, 0.0);
    
    // Pre-allocate position history.
    vector<Vector> pos_history;
    pos_history.reserve(num_steps);
    
    // Build desired trajectory: pure vertical motion.
    vector<Vector> pos_desired;
    pos_desired.reserve(num_steps);
    double T_ascent = 10.0;
    double T_hover_top = 5.0;
    double T_descent = 10.0;
    for (int i = 0; i < num_steps; i++) {
        double t_val = time[i];
        double z_desired = 0.0;
        if (t_val <= T_ascent)
            z_desired = (100.0 / T_ascent) * t_val;
        else if (t_val <= T_ascent + T_hover_top)
            z_desired = 100.0;
        else if (t_val <= T_ascent + T_hover_top + T_descent)
            z_desired = 100.0 - (100.0 / T_descent) * (t_val - T_ascent - T_hover_top);
        else
            z_desired = 0.0;
        Vector des(3, 0.0);
        des(2,0) = z_desired;
        pos_desired.push_back(des);
    }
    
    // Zero wind.
    Vector v_wind(3, 0.0);
    
    // Main simulation loop.
    for (int step = 0; step < num_steps; step++) {
        cout << "Step: " << step << " / " << num_steps << "\n";
        // Gravity force (world frame).
        Vector F_gravity(3, 0.0);
        F_gravity(2,0) = -P.m * P.g;
        
        // Constant thrust magnitude, clipped to [T_min, T_max].
        double F_thrust_mag = 50.0;
        if (F_thrust_mag < P.T_min) F_thrust_mag = P.T_min;
        if (F_thrust_mag > P.T_max) F_thrust_mag = P.T_max;
        
        // cout << "Passed thrust limits.\n";
        // Update COM and COP offsets.
        calculate_COM_and_COP_offset(P, thrust_gimbal);
        
        // cout << "debug\n";
        // Compute thrust force and torque (body frame).
        pair<Vector, Vector> thrust = get_thrust_body(P, F_thrust_mag, thrust_gimbal);
        Vector F_thrust_body = thrust.first;
        Vector T_thrust_body = thrust.second;
        // cout << "debug thrust force / torque\n";
        // Compute drag force and torque.
        pair<Vector, Vector> drag = get_drag_body(P, att, vel, v_wind);
        Vector F_drag_body = drag.first;
        Vector T_drag_body = drag.second;
        // cout << "debug drag forces\n";
        // Transform body-frame forces to world frame using the attitude quaternion.
        Matrix R_att = att.toRotationMatrix();  // 3x3 rotation matrix.
        Vector F_thrust_world = R_att.multiply(F_thrust_body);
        Vector F_drag_world = R_att.multiply(F_drag_body);
        Vector F_net = vectorAdd(F_gravity, vectorAdd(F_thrust_world, F_drag_world));
        // cout << "debug transform\n";
        // Total torque (only from thrust and drag, as gimbal torque is zero).
        Vector T_net = R_att.multiply(T_thrust_body.add(T_drag_body));
        // cout << "debug total torque\n";
        // Update dynamics.
        State st = update_dynamics(P, pos, vel, att, ang_vel, F_net, T_net, dt);
        // cout << "debug update dynamics\n";
        pos = st.pos;
        vel = st.vel;
        att = st.att;
        ang_vel = st.ang_vel;
        // cout << "debug update Dynamics\n";
        // Record current position.
        pos_history.push_back(pos);
        // cout << "end of iteration k";
    }
    
    // Write position history to CSV.
    ofstream file("histories.csv");
    if (!file) {
        cerr << "Error opening histories.csv for writing." << endl;
        return;
    }
    for (int i = 0; i < num_steps; i++) {
        file << pos_history[i](0,0) << "," << pos_history[i](1,0) << "," << pos_history[i](2,0) << "\n";
    }
    file.close();
    cout << "Simulation complete. Position history written to histories.csv" << endl;
}

//------------------------- Main Entry Point ---------------------------

int main() {
    // Define and initialize rocket parameters.
    RocketParams P;
    P.m_static = 1.0;
    P.m_gimbal_top = 1.0;
    P.m_gimbal_bottom = 1.0;
    P.m = P.m_static + P.m_gimbal_top + P.m_gimbal_bottom;
    
    // Set all offset vectors to zero (3x1).
    P.gimbal_top_COM_offset = Vector(3, 0.0);
    P.gimbal_bottom_COM_offset = Vector(3, 0.0);
    P.COM_offset = Vector(3, 0.0);
    P.COP = Vector(3, 0.0);          // Can be set as needed.
    P.COP_offset = Vector(3, 0.0);
    P.gimbal_offset = Vector(3, 0.0);
    P.gimbal_x_distance = Vector(3, 0.0);
    P.gimbal_y_distance = Vector(3, 0.0);
    
    P.g = 9.81;
    P.Cd_x = 0.1;  P.Cd_y = 0.1;  P.Cd_z = 0.1;
    P.A_x = 0.7;   P.A_y = 0.7;   P.A_z = 0.3;
    P.air_density = 1.225;
    
    // Inertia: define a 3x3 matrix.
    P.I = Matrix(3, 3, 0.0);
    P.I(0,0) = 1;  P.I(0,1) = 0;  P.I(0,2) = 0;
    P.I(1,0) = 0;  P.I(1,1) = 1;  P.I(1,2) = 0;
    P.I(2,0) = 0;  P.I(2,1) = 0;  P.I(2,2) = 1;
    P.Inv_I = P.I.inverse();
    
    P.gimbal_top_I = 1.0;
    P.gimbal_bottom_I = 1.0;
    
    P.T_max = 100.0;
    P.T_min = 0.0;
    P.gimbal_speed = 5.0;
    P.gimbal_acceleration = 2.0;
    
    P.dt = 0.001;
    
    simulate(P);
    return 0;
}
